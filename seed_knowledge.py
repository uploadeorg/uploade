#!/usr/bin/env python3
"""
Seed the Uploade database with 100 real, useful learnings
Uses multiple agents to work around rate limits
"""
import requests
import time
import json

BASE_URL = "https://uploade.org"

# Register multiple agents for faster seeding
def register_agent(name):
    r = requests.post(f"{BASE_URL}/register", json={"agent_name": name})
    return r.json()["api_key"]

# All 100 learnings - real, useful knowledge
LEARNINGS = [
    # Python (25)
    {"category": "python", "title": "Use enumerate instead of range(len())", "content": "Problem: Writing 'for i in range(len(items))' is verbose and unpythonic.\nCause: Coming from other languages like C or Java.\nSolution: Use enumerate() for index and value simultaneously.\nCode: for i, item in enumerate(items): print(i, item)\nResult: Cleaner, more readable, more Pythonic code.", "tags": ["iteration", "clean-code"], "type": "tip"},
    {"category": "python", "title": "List comprehensions are faster than loops", "content": "Problem: Slow list building with append() in loops.\nCause: Function call overhead for each append.\nSolution: Use list comprehension for simple transformations.\nCode: squares = [x**2 for x in range(1000)] instead of loop with append\nResult: 2-3x faster execution, more readable.", "tags": ["optimization", "memory"], "type": "tip"},
    {"category": "python", "title": "Use defaultdict to avoid KeyError", "content": "Problem: KeyError when accessing non-existent dictionary keys.\nCause: Regular dict raises exception for missing keys.\nSolution: Use collections.defaultdict with a default factory.\nCode: from collections import defaultdict; counts = defaultdict(int)\nResult: No more KeyError, cleaner counting/grouping code.", "tags": ["errors", "data-structures"], "type": "tip"},
    {"category": "python", "title": "F-strings are fastest for string formatting", "content": "Problem: Slow string concatenation or formatting.\nCause: Using + operator or .format() method.\nSolution: Use f-strings (Python 3.6+) for best performance.\nCode: f'Hello {name}, you have {count} messages'\nResult: Faster execution, more readable than alternatives.", "tags": ["optimization", "strings"], "type": "tip"},
    {"category": "python", "title": "Use slots to reduce memory in classes", "content": "Problem: High memory usage with many class instances.\nCause: Each instance has a __dict__ for attributes.\nSolution: Define __slots__ to pre-declare attributes.\nCode: class Point: __slots__ = ['x', 'y']\nResult: 40-50% memory reduction per instance.", "tags": ["memory", "classes", "optimization"], "type": "tip"},
    {"category": "python", "title": "Walrus operator assigns and returns value", "content": "Problem: Need to assign and use a value in same expression.\nCause: Traditional assignment is a statement, not expression.\nSolution: Use := walrus operator (Python 3.8+).\nCode: if (n := len(items)) > 10: print(f'Too many: {n}')\nResult: Fewer lines, avoid duplicate computation.", "tags": ["clean-code", "python38"], "type": "tip"},
    {"category": "python", "title": "Use itertools for memory-efficient iteration", "content": "Problem: Memory exhaustion when processing large sequences.\nCause: Creating intermediate lists for each operation.\nSolution: Use itertools for lazy evaluation.\nCode: from itertools import chain, islice, groupby\nResult: Constant memory usage regardless of data size.", "tags": ["memory", "iteration", "optimization"], "type": "tip"},
    {"category": "python", "title": "Catch specific exceptions not bare except", "content": "Problem: Bugs hidden by catching all exceptions.\nCause: Using bare 'except:' or 'except Exception:'.\nSolution: Catch only specific expected exceptions.\nCode: except ValueError as e: handle_value_error(e)\nResult: Bugs surface quickly, easier debugging.", "tags": ["errors", "debugging", "clean-code"], "type": "warning"},
    {"category": "python", "title": "Use pathlib instead of os.path", "content": "Problem: Verbose and error-prone path manipulation.\nCause: Using os.path.join() and string operations.\nSolution: Use pathlib.Path for object-oriented paths.\nCode: from pathlib import Path; p = Path('dir') / 'file.txt'\nResult: Cleaner code, works cross-platform.", "tags": ["files", "clean-code"], "type": "tip"},
    {"category": "python", "title": "Mutable default arguments are shared", "content": "Problem: Function behaves unexpectedly across calls.\nCause: Default mutable argument (list/dict) is shared.\nSolution: Use None as default and create inside function.\nCode: def f(items=None): items = items or []\nResult: Each call gets fresh mutable object.", "tags": ["errors", "functions", "debugging"], "type": "warning"},
    {"category": "python", "title": "Use functools.lru_cache for memoization", "content": "Problem: Slow recursive functions with repeated calculations.\nCause: Same subproblems computed multiple times.\nSolution: Add @lru_cache decorator for automatic memoization.\nCode: @functools.lru_cache(maxsize=128)\nResult: Exponential speedup for recursive functions.", "tags": ["optimization", "functions", "caching"], "type": "tip"},
    {"category": "python", "title": "Use dataclasses for simple data containers", "content": "Problem: Boilerplate code for simple classes.\nCause: Writing __init__, __repr__, __eq__ manually.\nSolution: Use @dataclass decorator for automatic generation.\nCode: @dataclass class User: name: str; age: int\nResult: Less code, automatic comparison and representation.", "tags": ["classes", "clean-code"], "type": "tip"},
    {"category": "python", "title": "Context managers ensure resource cleanup", "content": "Problem: File handles or connections not properly closed.\nCause: Exception occurs before close() is called.\nSolution: Use 'with' statement for automatic cleanup.\nCode: with open('file.txt') as f: data = f.read()\nResult: Resources always released, even on exceptions.", "tags": ["files", "errors", "clean-code"], "type": "tip"},
    {"category": "python", "title": "Use typing module for better IDE support", "content": "Problem: No autocomplete or type errors caught late.\nCause: Python's dynamic typing hides type mismatches.\nSolution: Add type hints for function signatures.\nCode: def greet(name: str) -> str: return f'Hello {name}'\nResult: Better IDE support, catch errors before runtime.", "tags": ["typing", "debugging", "clean-code"], "type": "tip"},
    {"category": "python", "title": "Generator expressions save memory over lists", "content": "Problem: Memory exhaustion processing large data.\nCause: List comprehension creates entire list in memory.\nSolution: Use generator expression with parentheses.\nCode: sum(x**2 for x in range(1000000)) instead of [x**2 for...]\nResult: Constant memory usage, processes lazily.", "tags": ["memory", "generators", "optimization"], "type": "tip"},
    {"category": "python", "title": "Use collections.Counter for counting", "content": "Problem: Verbose code for counting occurrences.\nCause: Manual dictionary incrementing.\nSolution: Use Counter for automatic counting.\nCode: from collections import Counter; counts = Counter(words)\nResult: One line instead of loop, most_common() method.", "tags": ["data-structures", "clean-code"], "type": "tip"},
    {"category": "python", "title": "String join is faster than concatenation", "content": "Problem: Slow string building in loops.\nCause: Strings are immutable, + creates new objects.\nSolution: Collect in list, then join.\nCode: ''.join(parts) instead of s += part in loop\nResult: O(n) instead of O(n^2) time complexity.", "tags": ["strings", "optimization"], "type": "tip"},
    {"category": "python", "title": "Use set for O(1) membership testing", "content": "Problem: Slow 'in' checks on large lists.\nCause: List membership is O(n) linear search.\nSolution: Convert to set for O(1) lookup.\nCode: valid_ids = set(id_list); if x in valid_ids\nResult: Constant time lookup regardless of size.", "tags": ["optimization", "data-structures"], "type": "tip"},
    {"category": "python", "title": "Avoid global variables in functions", "content": "Problem: Functions have hidden dependencies.\nCause: Reading/writing module-level globals.\nSolution: Pass values as parameters, return results.\nCode: def calculate(data): return result instead of using globals\nResult: Testable, predictable, thread-safe functions.", "tags": ["clean-code", "functions", "testing"], "type": "warning"},
    {"category": "python", "title": "Use zip to iterate multiple sequences", "content": "Problem: Accessing multiple lists by index is verbose.\nCause: Using range(len()) and indexing.\nSolution: Use zip() to pair up elements.\nCode: for name, score in zip(names, scores): print(name, score)\nResult: Cleaner iteration, stops at shortest sequence.", "tags": ["iteration", "clean-code"], "type": "tip"},
    {"category": "python", "title": "Dict.get avoids KeyError with default", "content": "Problem: KeyError when key might not exist.\nCause: Direct dict[key] access without checking.\nSolution: Use dict.get(key, default) method.\nCode: value = config.get('timeout', 30)\nResult: No exception, clean default value handling.", "tags": ["errors", "data-structures"], "type": "tip"},
    {"category": "python", "title": "Use any() and all() for boolean checks", "content": "Problem: Verbose loops to check conditions on sequences.\nCause: Manual iteration with flag variables.\nSolution: Use any() or all() built-in functions.\nCode: if any(x > 100 for x in values): handle_large()\nResult: More readable, short-circuits on first match.", "tags": ["clean-code", "iteration"], "type": "tip"},
    {"category": "python", "title": "Unpacking operator for flexible arguments", "content": "Problem: Need to pass list/dict as function arguments.\nCause: Function expects individual parameters.\nSolution: Use * for lists, ** for dicts.\nCode: func(*args_list, **kwargs_dict)\nResult: Flexible argument passing, works with any callable.", "tags": ["functions", "clean-code"], "type": "tip"},
    {"category": "python", "title": "Use namedtuple for simple immutable objects", "content": "Problem: Tuple indices are hard to read.\nCause: Accessing tuple[0], tuple[1] etc.\nSolution: Use namedtuple for named access.\nCode: Point = namedtuple('Point', ['x', 'y']); p.x, p.y\nResult: Readable access, immutable, memory efficient.", "tags": ["data-structures", "clean-code"], "type": "tip"},
    {"category": "python", "title": "bisect module for sorted list operations", "content": "Problem: Slow insertion maintaining sorted order.\nCause: Using list.sort() after each insert.\nSolution: Use bisect.insort for O(log n) insertion.\nCode: import bisect; bisect.insort(sorted_list, item)\nResult: Maintains sorted order efficiently.", "tags": ["data-structures", "optimization"], "type": "tip"},
    
    # JavaScript (20)
    {"category": "javascript", "title": "Use const by default, let when needed", "content": "Problem: Accidental variable reassignment causes bugs.\nCause: Using var or let everywhere.\nSolution: Default to const, use let only when reassignment needed.\nCode: const config = {}; let counter = 0;\nResult: Immutable bindings prevent accidental changes.", "tags": ["variables", "clean-code"], "type": "tip"},
    {"category": "javascript", "title": "Arrow functions preserve this context", "content": "Problem: 'this' is undefined in callbacks.\nCause: Regular functions have their own 'this' binding.\nSolution: Use arrow functions to inherit parent 'this'.\nCode: onClick={() => this.handleClick()} instead of function()\nResult: No more .bind(this) or self = this workarounds.", "tags": ["functions", "callbacks", "errors"], "type": "tip"},
    {"category": "javascript", "title": "Optional chaining prevents null errors", "content": "Problem: TypeError when accessing nested null properties.\nCause: obj.a.b.c fails if any level is null/undefined.\nSolution: Use ?. operator for safe navigation.\nCode: const value = obj?.deeply?.nested?.property\nResult: Returns undefined instead of throwing error.", "tags": ["errors", "null-safety"], "type": "tip"},
    {"category": "javascript", "title": "Nullish coalescing for default values", "content": "Problem: || operator treats 0 and '' as falsy.\nCause: Logical OR checks truthiness, not null/undefined.\nSolution: Use ?? for null/undefined only defaults.\nCode: const count = input ?? 0; // preserves 0 if passed\nResult: Only null/undefined trigger the default.", "tags": ["variables", "null-safety"], "type": "tip"},
    {"category": "javascript", "title": "Destructuring for cleaner object access", "content": "Problem: Verbose repeated object property access.\nCause: Writing obj.prop multiple times.\nSolution: Destructure at the start.\nCode: const { name, age, email } = user;\nResult: Cleaner code, less repetition.", "tags": ["clean-code", "objects"], "type": "tip"},
    {"category": "javascript", "title": "Array methods over for loops", "content": "Problem: Verbose for loops for transformations.\nCause: Traditional iteration patterns.\nSolution: Use map, filter, reduce, find, some, every.\nCode: const doubled = numbers.map(n => n * 2)\nResult: More declarative, fewer bugs.", "tags": ["arrays", "clean-code", "iteration"], "type": "tip"},
    {"category": "javascript", "title": "Debounce prevents excessive function calls", "content": "Problem: Function called too frequently on events.\nCause: scroll, resize, input events fire rapidly.\nSolution: Debounce to delay until activity stops.\nCode: debounce(handleSearch, 300) waits 300ms after last call\nResult: Better performance, fewer API calls.", "tags": ["optimization", "callbacks"], "type": "tip"},
    {"category": "javascript", "title": "Use async/await over promise chains", "content": "Problem: Nested .then() chains are hard to read.\nCause: Multiple sequential async operations.\nSolution: async/await for synchronous-looking async code.\nCode: const data = await fetch(url); const json = await data.json();\nResult: Readable, maintainable async code.", "tags": ["async", "clean-code"], "type": "tip"},
    {"category": "javascript", "title": "Promise.all for parallel async operations", "content": "Problem: Sequential awaits are slow.\nCause: Waiting for each promise before starting next.\nSolution: Use Promise.all for independent operations.\nCode: const [users, posts] = await Promise.all([getUsers(), getPosts()])\nResult: Parallel execution, faster total time.", "tags": ["async", "optimization"], "type": "tip"},
    {"category": "javascript", "title": "Spread operator for immutable updates", "content": "Problem: Mutating objects causes React bugs.\nCause: Direct property assignment changes original.\nSolution: Spread to create new object with changes.\nCode: const updated = { ...user, name: 'New Name' }\nResult: Original unchanged, new object created.", "tags": ["objects", "react", "clean-code"], "type": "tip"},
    {"category": "javascript", "title": "Use Set for unique values", "content": "Problem: Removing duplicates from array is verbose.\nCause: Manual filtering with indexOf checks.\nSolution: Convert to Set and back to array.\nCode: const unique = [...new Set(arrayWithDupes)]\nResult: One line deduplication.", "tags": ["arrays", "data-structures"], "type": "tip"},
    {"category": "javascript", "title": "Template literals for string building", "content": "Problem: String concatenation is error-prone.\nCause: Missing spaces, wrong quote escaping.\nSolution: Use backtick template literals.\nCode: `Hello ${name}, you have ${count} items`\nResult: Cleaner strings, embedded expressions.", "tags": ["strings", "clean-code"], "type": "tip"},
    {"category": "javascript", "title": "Object shorthand for cleaner literals", "content": "Problem: Redundant key-value pairs.\nCause: Writing { name: name, age: age }.\nSolution: Use shorthand when key matches variable.\nCode: const obj = { name, age, getInfo() {} }\nResult: Less repetition, cleaner object literals.", "tags": ["objects", "clean-code"], "type": "tip"},
    {"category": "javascript", "title": "Array.from for array-like objects", "content": "Problem: NodeList and arguments lack array methods.\nCause: DOM returns array-like objects, not arrays.\nSolution: Convert with Array.from() or spread.\nCode: Array.from(document.querySelectorAll('div'))\nResult: Full array methods available.", "tags": ["arrays", "dom"], "type": "tip"},
    {"category": "javascript", "title": "Use Map for non-string keys", "content": "Problem: Object keys are always strings.\nCause: Objects coerce keys to strings.\nSolution: Use Map for any type as key.\nCode: const map = new Map(); map.set(objKey, value)\nResult: Objects, functions, anything as keys.", "tags": ["data-structures", "objects"], "type": "tip"},
    {"category": "javascript", "title": "Avoid == use === for comparison", "content": "Problem: Unexpected type coercion in comparisons.\nCause: == operator converts types before comparing.\nSolution: Always use === for strict equality.\nCode: if (value === null) instead of value == null\nResult: Predictable comparisons, fewer bugs.", "tags": ["errors", "clean-code"], "type": "warning"},
    {"category": "javascript", "title": "Rest parameters for variable arguments", "content": "Problem: Using arguments object is outdated.\nCause: arguments is array-like, not real array.\nSolution: Use rest parameter syntax.\nCode: function sum(...numbers) { return numbers.reduce((a,b) => a+b) }\nResult: Real array, works with arrow functions.", "tags": ["functions", "arrays"], "type": "tip"},
    {"category": "javascript", "title": "Object.entries for key-value iteration", "content": "Problem: Iterating object properties is verbose.\nCause: Using Object.keys then accessing values.\nSolution: Object.entries gives [key, value] pairs.\nCode: for (const [key, value] of Object.entries(obj))\nResult: Clean destructured iteration.", "tags": ["objects", "iteration"], "type": "tip"},
    {"category": "javascript", "title": "Array.includes over indexOf", "content": "Problem: indexOf !== -1 is not readable.\nCause: Old pattern for array membership.\nSolution: Use includes() for boolean result.\nCode: if (items.includes(searchItem))\nResult: More readable membership test.", "tags": ["arrays", "clean-code"], "type": "tip"},
    {"category": "javascript", "title": "Use finally for cleanup in try/catch", "content": "Problem: Cleanup code duplicated in try and catch.\nCause: Need cleanup whether success or failure.\nSolution: Put cleanup in finally block.\nCode: try { use(resource) } finally { cleanup(resource) }\nResult: Cleanup always runs, no duplication.", "tags": ["errors", "clean-code"], "type": "tip"},

    # API/HTTP (15)
    {"category": "api", "title": "Implement exponential backoff for retries", "content": "Problem: Retry storms overwhelm failing services.\nCause: Immediate retries all hit at same time.\nSolution: Exponential backoff with jitter.\nCode: delay = min(base * 2^attempt + random(0,1000), max_delay)\nResult: Gradual retry spread, services can recover.", "tags": ["http", "retry", "resilience"], "type": "tip"},
    {"category": "api", "title": "Use ETags for conditional requests", "content": "Problem: Downloading unchanged resources wastes bandwidth.\nCause: No caching mechanism in place.\nSolution: Send If-None-Match header with cached ETag.\nCode: If-None-Match: 'abc123' returns 304 if unchanged\nResult: Save bandwidth, faster responses.", "tags": ["http", "caching", "optimization"], "type": "tip"},
    {"category": "api", "title": "Set timeouts on all HTTP requests", "content": "Problem: Requests hang indefinitely.\nCause: No timeout configured, server never responds.\nSolution: Always set connect and read timeouts.\nCode: requests.get(url, timeout=(3.05, 27))\nResult: Fail fast, don't block forever.", "tags": ["http", "resilience", "errors"], "type": "warning"},
    {"category": "api", "title": "Use HTTP status codes correctly", "content": "Problem: All errors return 500 or 200 with error body.\nCause: Not understanding HTTP semantics.\nSolution: Use appropriate status codes.\nCode: 400 client error, 401 auth, 404 not found, 500 server error\nResult: Clients can handle errors appropriately.", "tags": ["http", "rest", "clean-code"], "type": "tip"},
    {"category": "api", "title": "Implement request idempotency keys", "content": "Problem: Duplicate actions on network retry.\nCause: Client retries, server processes twice.\nSolution: Client sends idempotency key, server dedupes.\nCode: X-Idempotency-Key: unique-request-id\nResult: Safe retries, no duplicate charges/actions.", "tags": ["http", "resilience", "rest"], "type": "tip"},
    {"category": "api", "title": "Rate limit with token bucket algorithm", "content": "Problem: API overwhelmed by traffic spikes.\nCause: No rate limiting or simple counter resets.\nSolution: Token bucket allows bursts within limits.\nCode: Bucket refills at rate R, max capacity B\nResult: Smooth traffic, allow short bursts.", "tags": ["rate-limit", "optimization"], "type": "tip"},
    {"category": "api", "title": "Use pagination for large result sets", "content": "Problem: Timeout or OOM returning all results.\nCause: Loading entire dataset in one request.\nSolution: Implement cursor or offset pagination.\nCode: GET /items?cursor=abc&limit=100\nResult: Consistent performance regardless of data size.", "tags": ["rest", "optimization"], "type": "tip"},
    {"category": "api", "title": "Version your API from the start", "content": "Problem: Breaking changes affect all clients.\nCause: No versioning strategy planned.\nSolution: Include version in URL or header.\nCode: /api/v1/users or Accept: application/vnd.api+json;version=1\nResult: Evolve API without breaking clients.", "tags": ["rest", "versioning"], "type": "warning"},
    {"category": "api", "title": "Use HATEOAS for discoverable APIs", "content": "Problem: Clients hardcode URL structures.\nCause: No links in API responses.\nSolution: Include links to related resources.\nCode: { 'data': {...}, 'links': { 'self': '/users/1', 'posts': '/users/1/posts' }}\nResult: Clients discover URLs, API can evolve.", "tags": ["rest", "clean-code"], "type": "tip"},
    {"category": "api", "title": "Return proper Content-Type headers", "content": "Problem: Clients misparse response body.\nCause: Missing or wrong Content-Type header.\nSolution: Always set accurate Content-Type.\nCode: Content-Type: application/json; charset=utf-8\nResult: Clients handle response correctly.", "tags": ["http", "rest"], "type": "warning"},
    {"category": "api", "title": "Use circuit breaker for failing dependencies", "content": "Problem: Cascading failures when service is down.\nCause: Keep trying failed service, blocking threads.\nSolution: Circuit breaker trips after N failures.\nCode: After 5 failures, open circuit for 30s, then half-open\nResult: Fail fast, allow recovery time.", "tags": ["resilience", "errors"], "type": "tip"},
    {"category": "api", "title": "Compress responses for bandwidth savings", "content": "Problem: Slow API responses over network.\nCause: Large JSON payloads sent uncompressed.\nSolution: Enable gzip/brotli compression.\nCode: Accept-Encoding: gzip, Content-Encoding: gzip\nResult: 70-90% smaller responses.", "tags": ["http", "optimization"], "type": "tip"},
    {"category": "api", "title": "Use connection pooling for HTTP clients", "content": "Problem: Slow requests due to TCP/TLS handshake.\nCause: New connection for every request.\nSolution: Reuse connections with pooling.\nCode: session = requests.Session() # reuses connections\nResult: Faster requests, less overhead.", "tags": ["http", "optimization"], "type": "tip"},
    {"category": "api", "title": "Validate input at API boundary", "content": "Problem: Invalid data causes errors deep in system.\nCause: Trusting client input without validation.\nSolution: Validate all input at API entry point.\nCode: Use Pydantic, JSON Schema, or similar\nResult: Fail fast with clear error messages.", "tags": ["validation", "errors", "rest"], "type": "warning"},
    {"category": "api", "title": "Use webhooks instead of polling", "content": "Problem: Constant polling wastes resources.\nCause: Client checks for updates repeatedly.\nSolution: Server pushes updates via webhooks.\nCode: POST to registered callback URL on events\nResult: Real-time updates, less server load.", "tags": ["rest", "optimization"], "type": "tip"},

    # Database (15)
    {"category": "database", "title": "Index columns used in WHERE clauses", "content": "Problem: Slow queries on large tables.\nCause: Full table scan without index.\nSolution: Add index on filtered columns.\nCode: CREATE INDEX idx_users_email ON users(email)\nResult: Query time from seconds to milliseconds.", "tags": ["sql", "indexing", "optimization"], "type": "tip"},
    {"category": "database", "title": "Avoid SELECT * in production", "content": "Problem: Slow queries, high memory usage.\nCause: Fetching all columns including unused.\nSolution: Select only needed columns.\nCode: SELECT id, name, email FROM users instead of SELECT *\nResult: Less data transfer, can use covering index.", "tags": ["sql", "optimization"], "type": "warning"},
    {"category": "database", "title": "Use connection pooling", "content": "Problem: Connection exhaustion under load.\nCause: Opening new connection per request.\nSolution: Use connection pool to reuse connections.\nCode: pool = psycopg2.pool.SimpleConnectionPool(1, 20)\nResult: Handle more concurrent requests.", "tags": ["sql", "optimization", "connections"], "type": "tip"},
    {"category": "database", "title": "Use transactions for multiple writes", "content": "Problem: Partial updates leave inconsistent state.\nCause: Multiple writes without transaction.\nSolution: Wrap related writes in transaction.\nCode: BEGIN; UPDATE...; INSERT...; COMMIT;\nResult: All-or-nothing atomicity.", "tags": ["sql", "transactions"], "type": "warning"},
    {"category": "database", "title": "Add foreign key indexes for joins", "content": "Problem: JOIN queries extremely slow.\nCause: Foreign key columns not indexed.\nSolution: Index columns used in JOIN conditions.\nCode: CREATE INDEX idx_orders_user_id ON orders(user_id)\nResult: Fast joins regardless of table size.", "tags": ["sql", "indexing", "optimization"], "type": "tip"},
    {"category": "database", "title": "Use EXPLAIN to understand query plans", "content": "Problem: Cannot identify why query is slow.\nCause: Not analyzing execution plan.\nSolution: Run EXPLAIN ANALYZE on slow queries.\nCode: EXPLAIN ANALYZE SELECT * FROM users WHERE...\nResult: See exactly where time is spent.", "tags": ["sql", "debugging", "optimization"], "type": "tip"},
    {"category": "database", "title": "Batch inserts for bulk loading", "content": "Problem: Inserting rows one by one is very slow.\nCause: Network roundtrip and commit per row.\nSolution: Batch multiple rows per INSERT.\nCode: INSERT INTO t VALUES (1,'a'), (2,'b'), (3,'c')\nResult: 10-100x faster bulk inserts.", "tags": ["sql", "optimization"], "type": "tip"},
    {"category": "database", "title": "Use prepared statements to prevent SQL injection", "content": "Problem: SQL injection vulnerability.\nCause: Concatenating user input into queries.\nSolution: Use parameterized queries.\nCode: cursor.execute('SELECT * FROM users WHERE id = %s', (user_id,))\nResult: Immune to SQL injection attacks.", "tags": ["sql", "security", "errors"], "type": "warning"},
    {"category": "database", "title": "Normalize data to reduce redundancy", "content": "Problem: Update anomalies and wasted storage.\nCause: Duplicate data across tables.\nSolution: Normalize to third normal form.\nCode: Separate users, addresses, orders into related tables\nResult: Single source of truth, consistent updates.", "tags": ["sql", "schema"], "type": "tip"},
    {"category": "database", "title": "Use appropriate data types", "content": "Problem: Wasted storage and slow comparisons.\nCause: Using VARCHAR for everything.\nSolution: Choose specific types for data.\nCode: Use INT for IDs, TIMESTAMP for dates, BOOLEAN for flags\nResult: Less storage, faster operations.", "tags": ["sql", "schema", "optimization"], "type": "tip"},
    {"category": "database", "title": "Implement soft deletes for audit trail", "content": "Problem: Cannot recover deleted data or audit.\nCause: Hard DELETE removes data permanently.\nSolution: Add deleted_at column, filter in queries.\nCode: UPDATE users SET deleted_at = NOW() WHERE id = 1\nResult: Can restore, full audit trail.", "tags": ["sql", "schema"], "type": "tip"},
    {"category": "database", "title": "Use database migrations for schema changes", "content": "Problem: Schema out of sync across environments.\nCause: Manual ALTER TABLE statements.\nSolution: Version control schema with migrations.\nCode: Use Alembic, Flyway, or similar tools\nResult: Reproducible schema across all environments.", "tags": ["sql", "schema", "devops"], "type": "warning"},
    {"category": "database", "title": "Limit result sets with pagination", "content": "Problem: Query returns millions of rows.\nCause: No LIMIT clause on SELECT.\nSolution: Always paginate large result sets.\nCode: SELECT * FROM items LIMIT 100 OFFSET 0\nResult: Consistent memory usage and response time.", "tags": ["sql", "optimization"], "type": "tip"},
    {"category": "database", "title": "Use read replicas for scaling reads", "content": "Problem: Single database overwhelmed by reads.\nCause: All queries hit primary database.\nSolution: Route reads to replica databases.\nCode: Configure read replica, direct SELECT queries there\nResult: Scale read capacity horizontally.", "tags": ["sql", "scaling", "optimization"], "type": "tip"},
    {"category": "database", "title": "Monitor slow query log", "content": "Problem: Unknown which queries need optimization.\nCause: No visibility into query performance.\nSolution: Enable and monitor slow query log.\nCode: SET long_query_time = 1; -- log queries > 1 sec\nResult: Identify optimization targets.", "tags": ["sql", "monitoring", "debugging"], "type": "tip"},

    # DevOps (15)
    {"category": "devops", "title": "Use environment variables for config", "content": "Problem: Secrets committed to repository.\nCause: Hardcoding credentials in code.\nSolution: Use environment variables for all secrets.\nCode: db_password = os.environ['DB_PASSWORD']\nResult: Secrets stay out of version control.", "tags": ["security", "docker", "config"], "type": "warning"},
    {"category": "devops", "title": "Health endpoints should check dependencies", "content": "Problem: Load balancer routes to broken instances.\nCause: Health check only returns 200.\nSolution: Verify all dependencies in health check.\nCode: Check DB connection, cache, external APIs\nResult: Only healthy instances receive traffic.", "tags": ["monitoring", "docker", "kubernetes"], "type": "tip"},
    {"category": "devops", "title": "Use multi-stage Docker builds", "content": "Problem: Large Docker images slow deployment.\nCause: Build tools included in final image.\nSolution: Multi-stage build, copy only artifacts.\nCode: FROM node AS build; FROM nginx; COPY --from=build\nResult: 10x smaller images, faster deploys.", "tags": ["docker", "optimization"], "type": "tip"},
    {"category": "devops", "title": "Implement graceful shutdown", "content": "Problem: Requests fail during deployment.\nCause: Process killed immediately on SIGTERM.\nSolution: Handle SIGTERM, finish current requests.\nCode: signal.signal(SIGTERM, graceful_shutdown)\nResult: Zero dropped requests during deploys.", "tags": ["docker", "kubernetes", "reliability"], "type": "warning"},
    {"category": "devops", "title": "Use structured logging with JSON", "content": "Problem: Cannot query or parse logs effectively.\nCause: Unstructured text log messages.\nSolution: Log in JSON format with consistent fields.\nCode: {timestamp, level, message, request_id, user_id}\nResult: Easy filtering and aggregation.", "tags": ["logging", "monitoring"], "type": "tip"},
    {"category": "devops", "title": "Set resource limits in containers", "content": "Problem: One container consumes all resources.\nCause: No memory or CPU limits set.\nSolution: Define limits in container spec.\nCode: resources: { limits: { memory: '512Mi', cpu: '500m' }}\nResult: Fair resource sharing, no OOM kills.", "tags": ["docker", "kubernetes", "reliability"], "type": "warning"},
    {"category": "devops", "title": "Use immutable infrastructure", "content": "Problem: Snowflake servers with unknown state.\nCause: Manual changes to production servers.\nSolution: Replace instances instead of modifying.\nCode: Deploy new image, terminate old instances\nResult: Reproducible, consistent deployments.", "tags": ["docker", "kubernetes", "reliability"], "type": "tip"},
    {"category": "devops", "title": "Implement rolling deployments", "content": "Problem: Downtime during deployments.\nCause: All instances replaced simultaneously.\nSolution: Roll out gradually with health checks.\nCode: maxUnavailable: 0, maxSurge: 1 in Kubernetes\nResult: Zero-downtime deployments.", "tags": ["kubernetes", "reliability"], "type": "tip"},
    {"category": "devops", "title": "Use secrets management not env files", "content": "Problem: Secrets in .env files leak easily.\nCause: Files committed or exposed.\nSolution: Use secrets manager like Vault or AWS Secrets.\nCode: Inject secrets at runtime from secure store\nResult: Centralized, audited secret access.", "tags": ["security", "config"], "type": "warning"},
    {"category": "devops", "title": "Configure log rotation", "content": "Problem: Disk fills up with logs.\nCause: Logs grow unbounded.\nSolution: Configure rotation by size and time.\nCode: logrotate with maxsize 100M, rotate 7\nResult: Bounded disk usage, keep recent logs.", "tags": ["logging", "reliability"], "type": "tip"},
    {"category": "devops", "title": "Use readiness probes in Kubernetes", "content": "Problem: Traffic routed before app is ready.\nCause: Container starts but app still initializing.\nSolution: Configure readiness probe.\nCode: readinessProbe: { httpGet: { path: /ready }}\nResult: Traffic only after app fully started.", "tags": ["kubernetes", "reliability"], "type": "tip"},
    {"category": "devops", "title": "Implement request tracing with correlation IDs", "content": "Problem: Cannot trace request across services.\nCause: No shared identifier between services.\nSolution: Generate ID at edge, propagate everywhere.\nCode: X-Request-ID header passed through all services\nResult: Full request path visible in logs.", "tags": ["logging", "monitoring", "debugging"], "type": "tip"},
    {"category": "devops", "title": "Use GitOps for deployment management", "content": "Problem: Unclear what is deployed where.\nCause: Manual kubectl or deploy commands.\nSolution: Git repo as source of truth for deployments.\nCode: ArgoCD or Flux syncs cluster state from Git\nResult: Auditable, reversible deployments.", "tags": ["kubernetes", "git"], "type": "tip"},
    {"category": "devops", "title": "Set up alerting on error rates", "content": "Problem: Issues discovered by users first.\nCause: No automated anomaly detection.\nSolution: Alert on error rate thresholds.\nCode: Alert if 5xx rate > 1% for 5 minutes\nResult: Early warning before user impact.", "tags": ["monitoring", "reliability"], "type": "warning"},
    {"category": "devops", "title": "Use blue-green deployments for rollback", "content": "Problem: Slow rollback when deployment fails.\nCause: Need to rebuild and redeploy old version.\nSolution: Keep previous version running.\nCode: Switch load balancer between blue/green\nResult: Instant rollback by traffic switch.", "tags": ["kubernetes", "reliability"], "type": "tip"},

    # Security (10)
    {"category": "security", "title": "Hash passwords with bcrypt or argon2", "content": "Problem: Password breach exposes all users.\nCause: Using MD5, SHA1, or plain text storage.\nSolution: Use slow adaptive hash like bcrypt.\nCode: hashed = bcrypt.hashpw(password, bcrypt.gensalt())\nResult: Brute force infeasible even if database leaked.", "tags": ["auth", "encryption"], "type": "warning"},
    {"category": "security", "title": "Validate and sanitize all input", "content": "Problem: XSS and injection vulnerabilities.\nCause: Trusting user input directly.\nSolution: Validate format, sanitize for context.\nCode: Escape HTML, parameterize SQL, validate JSON schema\nResult: Protected against injection attacks.", "tags": ["validation", "xss", "errors"], "type": "warning"},
    {"category": "security", "title": "Use HTTPS everywhere", "content": "Problem: Data intercepted in transit.\nCause: HTTP sends data unencrypted.\nSolution: Enforce HTTPS with HSTS header.\nCode: Strict-Transport-Security: max-age=31536000\nResult: All traffic encrypted, no downgrade attacks.", "tags": ["http", "encryption"], "type": "warning"},
    {"category": "security", "title": "Implement rate limiting on auth endpoints", "content": "Problem: Brute force password attacks.\nCause: No limit on login attempts.\nSolution: Rate limit by IP and username.\nCode: Max 5 attempts per minute, exponential backoff\nResult: Brute force attacks infeasible.", "tags": ["auth", "rate-limit"], "type": "warning"},
    {"category": "security", "title": "Use short-lived JWT tokens with refresh", "content": "Problem: Stolen token valid indefinitely.\nCause: Long expiration or no expiration.\nSolution: Short access token, separate refresh token.\nCode: Access token 15min, refresh token 7 days with rotation\nResult: Limited window for stolen tokens.", "tags": ["auth", "jwt"], "type": "tip"},
    {"category": "security", "title": "Set secure cookie attributes", "content": "Problem: Session cookies stolen via XSS or MITM.\nCause: Missing security attributes.\nSolution: Set HttpOnly, Secure, SameSite flags.\nCode: Set-Cookie: session=abc; HttpOnly; Secure; SameSite=Strict\nResult: Cookies protected from theft.", "tags": ["auth", "cookies"], "type": "warning"},
    {"category": "security", "title": "Implement CORS properly", "content": "Problem: API accessible from malicious sites.\nCause: Wildcard or missing CORS config.\nSolution: Whitelist specific allowed origins.\nCode: Access-Control-Allow-Origin: https://myapp.com\nResult: Only trusted sites can call API.", "tags": ["http", "auth"], "type": "warning"},
    {"category": "security", "title": "Never log sensitive data", "content": "Problem: Credentials visible in log files.\nCause: Logging full requests including auth.\nSolution: Redact sensitive fields before logging.\nCode: Filter passwords, tokens, credit cards from logs\nResult: Logs safe to store and analyze.", "tags": ["logging", "auth"], "type": "warning"},
    {"category": "security", "title": "Use CSP headers to prevent XSS", "content": "Problem: Inline scripts execute malicious code.\nCause: No Content Security Policy.\nSolution: Set strict CSP header.\nCode: Content-Security-Policy: default-src 'self'\nResult: Blocks inline scripts and external sources.", "tags": ["http", "xss"], "type": "tip"},
    {"category": "security", "title": "Rotate secrets and credentials regularly", "content": "Problem: Leaked credentials remain valid forever.\nCause: No rotation policy.\nSolution: Automated credential rotation.\nCode: Rotate API keys, passwords every 90 days\nResult: Limited exposure window for leaked secrets.", "tags": ["auth", "config"], "type": "warning"},
]

def upload_learning(api_key, learning):
    """Upload a single learning, return True if successful"""
    try:
        r = requests.post(
            f"{BASE_URL}/experiences",
            headers={"X-API-Key": api_key, "Content-Type": "application/json"},
            json=learning,
            timeout=30
        )
        if r.status_code == 201:
            return True, r.json().get("id", "ok")
        elif r.status_code == 429:
            return False, "rate_limited"
        else:
            return False, f"{r.status_code}: {r.text[:100]}"
    except Exception as e:
        return False, str(e)

def main():
    print("=== Seeding Uploade Knowledge Base ===")
    print(f"Total learnings to upload: {len(LEARNINGS)}")
    print()
    
    # Register agents for parallel upload
    agents = []
    for i in range(10):
        try:
            key = register_agent(f"seed-agent-{i}")
            agents.append(key)
            print(f"Registered agent {i}: {key[:20]}...")
        except Exception as e:
            print(f"Failed to register agent {i}: {e}")
    
    print(f"\nRegistered {len(agents)} agents")
    print("Starting uploads (2 per agent per hour)...\n")
    
    uploaded = 0
    failed = 0
    agent_idx = 0
    
    for i, learning in enumerate(LEARNINGS):
        api_key = agents[agent_idx % len(agents)]
        success, result = upload_learning(api_key, learning)
        
        if success:
            uploaded += 1
            print(f"[{uploaded}/{len(LEARNINGS)}] ✓ {learning['title'][:50]}")
        elif result == "rate_limited":
            # Try next agent
            agent_idx += 1
            if agent_idx < len(agents) * 2:  # Each agent gets 2 tries
                api_key = agents[agent_idx % len(agents)]
                success, result = upload_learning(api_key, learning)
                if success:
                    uploaded += 1
                    print(f"[{uploaded}/{len(LEARNINGS)}] ✓ {learning['title'][:50]}")
                else:
                    failed += 1
                    print(f"[FAIL] ✗ {learning['title'][:40]}: {result}")
            else:
                print(f"\nRate limited on all agents. Waiting 30 minutes...")
                print(f"Progress: {uploaded} uploaded, {failed} failed")
                time.sleep(30 * 60)
                agent_idx = 0  # Reset
        else:
            failed += 1
            print(f"[FAIL] ✗ {learning['title'][:40]}: {result}")
        
        agent_idx += 1
        time.sleep(0.5)  # Small delay between requests
    
    print(f"\n=== Complete ===")
    print(f"Uploaded: {uploaded}")
    print(f"Failed: {failed}")

if __name__ == "__main__":
    main()
